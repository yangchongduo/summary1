#### 修改placeholder的背景颜色
```
input::-webkit-input-placeholder{
	font-size: .26rem;
	color: #CCCCCC !important;
}
```
#### es6 返回函数结果不写return
```
calcCircumference = diameter => (
  Math.PI * diameter;
)
```
#### Array.find 
```
const pets = [
  { type: 'Dog', name: 'Max'},
  { type: 'Cat', name: 'Karl'},
  { type: 'Dog', name: 'Tommy'},
]
```
```
pet = pets.find(pet => pet.type ==='Dog' && pet.name === 'Tommy');
console.log(pet); // { type: 'Dog', name: 'Tommy' }
```
#### 默认值得设置  
>1 接口挂了，能够正常显示页面。。   
#### 页面性能的优化  
>1 webp  
>2 图片尽量使用base64   
>3 默认占位符和图片  
>4 图片延迟加载 
>>1  计算offsetTop那些
>>2  获取正式图片之后通过，先给默认图占位，通过setTimeout进行赋值，问题是假如出现多张图片呢？ (vue-lazyload.js源码实现重点)
```
  this.lazyLoadHandler = throttle(() => {
                let catIn = false
                this.ListenerQueue.forEach(listener => {
                    if (listener.state.loaded) return
                    catIn = listener.checkInView()
                    catIn && listener.load()
                })
            }, 200)
```
``` 
react-lazyload
return function debounced() {
    context = this;
    args = arguments;
    timestamp = +(new Date());

    const callNow = immediate && !timeout;
    if (!timeout) {
      timeout = setTimeout(later, wait);
    }

    if (callNow) {
      result = func.apply(context, args);
      context = null;
      args = null;
    }

    return result;
```
>5 http2(终极处理方案) 

#### || && ？：
```
:denomination="good.type==4||good.type==12 || good.type==13?true:false"  错误
:denomination="good.type==4||good.type==12 || good.type==13"  正确
本身就是false 和true 无需赋值
-----三元运算符---------
 :coupon-type="good.type==4 || good.type==12 || good.type==13?'ious':'material'"
--------或bing----------------
  <span v-if="coupon.type !== '7'&& coupon.type !== '8'">￥</span>                                  ****不相等&&***8
   {{ coupon.type !== '7' && coupon.type !== '8' ? coupon.money : coupon.rebate }}
 <span v-if="coupon.type === '7'|| coupon.type === '8'">折</span>                                   ****相等是||*****
```
#### hosts
>1 同一个地址，hosts不同，就会到不同的机器上去。这就是 hosts的作用  
>2 假如没有的话就进行DNS域名解析服务器进行IP地址的解析。  
#### 灰度测试
>1 后端全量上线，通过种植cookie，cookie种植了user_id,通过计算user_id进行分别达到后端的机器上，       
>2 怎么达到后端的机器上呢？通过lvs这实现负载均衡和分发  
#### 数组的every
场景:一个数组是否全部等于一个数，相等就返回true，不相等就false
```
const flag = ['xx','xx','xx'].every((item)=>{
  return item === 'xx'
})
console.log(flag);
```
#### 登陆的整体流程
以接口参数的形式传递token，fe负责存放，和过去时间，后端也可自行设置时间
```
>1. 首先前端会发送登录的方式，可以是名字，邮箱，很多第三方登录等等。   
>2. 注册之后肯定会在表里面有数据，根据你的登录方式，获取获取id，然后通过id，生成token，手动设置放在redis里面，然后通过参数传给FE，FE获取之后，很多操作，乐视是放在localstorage里面，每次发送请求的通过写中间件的方式，每次获取token发送  
>3 RD通过获取的token，验证，反解析出id，然后在reids里面查询，是否存在，存在更新token的时间，根据id，还有其他参数，然后进行查表写数据
```
```
RD自己种植token，前端不做任何事情，可以放在session里面
```
#### session放在mongo
```
store: new MongoStore({
    db: settings.db,
    host: settings.host,
    port: settings.port,
  })
```
#### redis
----------------------------
```
第一个使景：下单页面是不可以让用户长时间停留的，进入这个页面预览的时候发送一个请求获取一个token，放在cookie，当点击的时候，发送请求，浏览器会带着token过去，然后对比，后端从session，redis里面获取，对比是否相同。验证也是
不相同就this.redirtl到登陆页面
```
#### 
#### 后端场景
---------------------
```
假如所有的请求接口，我们需要保证在登陆情况下，每次请求都会走这个中间件，我们可以写个中间件（如果没有登陆的话就重定向到this.redirect登陆页面）
前端会发送cookie到后端，后端如何存取cookie，进行对比了 redis还是session？ 直接读取redis比较快
```
#### 后台开发与前端开发联调协同场景
-------------------------
```
1：许多场景需要登录才可以访问，因为后台开发的域名和前端的不一样，从node层请求接口。目的就是为了能够在浏览中种植cookie
我们可以直接访问后端提供的地址。在浏览器下种植cookie，（因为是开发环境下，前端地址131.12.1.1 后端地址121.3.3.3我们种植完cookie ）
拷贝就可以了
```
#### window的replace和href的区别
-----------------------------
```
下单页面 点个按钮，执行一个方法 replace的方式。跳转到支付页，回退不是应该会退到下单页面的，应该在详情页，这个时候就replace
个人中心：点击还款，换完之后应该回到个人中心，不应该回到其他页面，所以用href
```
#### pc端的业务 登录 查看可以看react的那个平台
----------------------------------------
```
设计思想:
     重点:就是每次发送请求都带着token 来验证是否过期；
    默认显示dashboard 在dashboard 里面来判断是否处理登录状态

    如何判断处于登录状态呢？
    通过cookie 或者localStorage 放在store中的 initialState 里面；

    然后跳转到登录页面；

    开始登录 登录我获取到token 放在localStorage里面 然后再次跳转到 '/'　　因为我默认显示的是dashboard
     dashboard 再次去加载获取权限 展示页面
     这个时候会返回我需要展示的东西，很多分支，但是我需要默认显示一些东西
     比如market 这个分支，借助了thunkMiddle这个东西 派发一个函数 dispatch(function);到market;
     
```
#### vue elemment业务逻辑
------------------------------
```
head 展示不同的组件 根据是否登录
1:手机短信登录 填写手机号，获取验证码 然后再次发送，重新跳转到food 页 确实比较好
2:下拉刷新加载数据。。。
3:轮播图
```
#### 执行一个函数，执行完之后想做一些事情，但是这个函数有异步
--------------------------
```
1： 异步回调 bad
var fn=(cb)=>{
    setTimeout(()=>{
        cb()
    },1000)
};
var cb=()=>{
    console.log('xxxxxxxxxx')
};
fn(cb);
2:promise
var fn1=()=>{
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve()
        },1000)
    })
};
fn1().then(()=>{
    console.log('---------------')
})
3 async and await 就不说了
```
#### 多次处理一个东西， html替换img css js的cdn 路径，  这次的处理基于上次的处理结果
-------------------------------------
```
var str='yangchongdu';
var str1=`${str}xxxx`;
var str2=`${str1}cccc`;
console.log(str2);
//bad
var str='yangchongduo';
var fn=()=>{
    return Promise.resolve(str).then((data)=>{
        return `${data}xxx`
    }).then((data)=>{
        return `${data}cccc`
    });
};
fn().then((data)=>{
    console.log(data)
})
```
