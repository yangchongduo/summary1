#### dup+tcp 什么是TCP粘包?
--------------------------
```
https://zhidao.baidu.com/question/479883658.html
UDP丢包是因为数据包在传送过程中丢失了 而TCP是基于流式的发送 并且存在丢包重发机制 TCP是可靠连接而UDP是不可靠的这个我就不多说了
关于TCP的粘包 正是由于TCP是流式传送的 也就是连接建立后可以一直不停的发送 并没有明确的边界定义 而你用UDP发送的时候 是可以按照一个一个数据包去发送的 一个数据包就是一个明确的边界
而TCP并没有数据包的概念 是完全流式的 他会开辟一个缓冲区 发送端往其中写入数据 每过一段时间就发送出去 然后接收端接收到这些数据 但是并不是说我发送了一次数据就肯定发送出去了 数据会在缓冲区中 有可能后续发送的数据和之前发送的数据同时存在缓冲区中随后一起发送 这就是粘包的一种形式 接收端也有产生粘包的情况 如果应用程序没有及时处理缓冲区中的数据 那么后续到达的数据会继续存放到缓冲区中 也就是2次接收的数据同时存在缓冲区中 下次取缓冲区的时候就会取出2次粘包后的数据 这是粘包的另外一种形式 还有其他许多形式 比如填充缓冲区到一半缓冲区满了直接发送了 但是其实那个包还没填充完全 这个就是不完整的粘包了 剩余数据会在下次发送的时候补上
关于解决方法 如果你是连续的整个数据流 比如发送文件 那么完全不考虑粘包也无所谓 因为可以建立连接后发送 发送完毕后断开连接 整个数据流就是整个一个文件 无论数据从那里切开都无所谓 整个拼接后依旧是整个一个文件的数据
如果你发送的数据是多次通信 比如把一个目录下所有的文件名都发送过去 那么就不能当作一个整体发送了 必须对他们划分边界 有一个很简单的处理方法 就是采用"数据长度+实际数据"的格式来发送数据 这个"数据长度"的格式是固定宽度的 比如4字节 可以表示0~4GB的宽度了 足够用了 这个宽度说明了后续实际数据的宽度 这样你就可以把粘包后的数据按照正确的宽度取出来了
每次都是取出4字节 随后按照正确的宽度取出后续部分的就OK了
如果你的所有数据都是固定宽度的 比如不停的发送温度数据 每个都是1字节 那么宽度已知了 每次你都取出一个1字节就OK了 所以就不用发送宽度数据了
当然你也可以按照建立连接断开连接来划分边界 每次发送数据都打开关闭一次连接 不过对于频繁的小数据量是不可取的做法 因为开销太大 建立连接和关闭连接也是需要耗费网络流量的
总而言之 粘包的情况是无法绝对避免的 因为网络环境是很复杂的 依赖发送和接收缓冲区的控制是不能保证100%的 只要在发送的数据中说明数据的宽度随后在接收部分按照这个宽度拆开就OK了 宽度全都是统一的已知宽度的情况下拆开更加容易 连在发送端填入宽度数据都可以省去了
```
#### 轻松排查线上Node内存泄漏问题
------------------------------
```
https://cnodejs.org/topic/58eb5d378cda07442731569f
```

#### pm2 cluter 模块启动多个进程？ 监听同一个端口号为什么能做到？
-----------------
```
Node.js cluster module ：
Luckily enough, Node.js offers the cluster module, which basically will spawn some workers which can all share any TCP connection.
nodejs 当 spawn 多个进程的时候，各子进程可以共享 tcp 连接 各个进程通过 IPC channels 
https://keymetrics.io/2015/03/26/pm2-clustering-made-easy/
https://github.com/jawil/blog/issues/7
pm2 的cluster 模式是基于node的原生cluster 做的吗？ 而 node原生模模块是基于子进程中的spawn模式吗
？ 他们之间共享通过ipc通道 共享 tcp链接吗？
```

#### module.exports和exports的区别
---------------------------------
```
(function (exports,require,module,__dirname,__filename) {
    //模块化 返回对象 暴露接口
    //__dirname __filename 是通过外界传进来的，所以可以在文件中访问
    exports = module.exports = {};
    //exports  = Person;//改变了exports指向但是，module没有变化
    function Person (){}
    //方法1：给exports增加属性会影响到module.exports值
    //方法2：直接改变module.exports
    //exports.person = Person =》
    exports = module.exports = {person:Person};
    //引用地址
    return module.exports;
    //如果导出的是引用数据类型 用module.exports =Function
    //错误方式epxorts = Function
})();
2:module.export    export 有什么区别
export=module.export={}
// 要是改变export的指向 增加属性是没有用的
return module.export 

```
#### 做什么事之前你要知道 你在做什么为什么这么多 ，这么做的好处是什么？
----------------------------------------------
       http://blog.csdn.net/leftfist/article/details/41891407
       切换上下文 就是 切换进程或者线程 任务，   
       IO的一种:
       因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据） 
       执行栈  堆一般是用来存储的数据的
       从上次gulp 来看 是node 的环境 服务器之间是不存在跨域的   前段和后台是存在跨域的
       有没有发现，这种proxy方式是没有同域机制的限制 了，前端面试常问的跨域方案都不是事儿；
       一百万用户一天请求一次也是一百万PV，一百万UV
        一个用户一天请求一百万次也是一百万PV，一UV
        ab只能是pv的压力 uv是没有办法测试的  其实一般一个 pv就是一个uv
        node是从事件队列里面一个一个的处理task，像php和java 就是那种 多个线程共同抢占 一个资源 同时上下文的切换，这都是需要消耗资源的；
#### 内存泄漏
---------------------------
```
内存快照常用与解决内存泄漏的问题. 快照工具推荐使用 heapdump 用来保存内存快照, 使用 devtool 来查看内存快照. 
使用 heapdump 保存内存快照时, 只会有 Node.js 环境中的对象, 不会受到干扰（如果使用 node-inspector 的话, 快照中会有前端的变量干扰）.
```
#### 错误模块
-----------------------
```
node-verror 处理的错误模块
```
