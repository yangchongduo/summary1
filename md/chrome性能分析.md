 ### stalled：
 ```
 网页加载时间过长，查看chrome时发现stalled都比较久：
 因为 dns 服务器对于该域名查询没有响应, 重试很久才成功.   我估计 stalled 多半是一些网络问题,  比如 dns ,  服务器不可达,  tcp reset 之类的问题.  
```
### Waiting： 在前端接口 content load 时间
```
包括DNS、socket连接和请求响应时间
页面请求 Waiting (TTFB) 时间过长:这他妈的waiting时间就是处理数据的时间  请求到达服务器  服务器根据请求内容去执行程序 
神马引入文件 载入类什么的  都在这段时间内执行   得出结果后  
反馈回来  尼玛~~~怪不得时间这么长 框架复杂度问题  越复杂的框架 请求时间越长 我勒个嚓嚓嘣!!!!!
```


浏览器缓存机制
	浏览器对于请求资源, 拥有一系列成熟的缓存策略。 按照发生的时间顺序分别为存储策略, 过期策略, 协商策略, 其中存储策略在收到响应后应用, 过期策略, 协商策略在发送请求前应用。
一、http header中与缓存有关的key: 
	① Cache-Control: 指定缓存机制，覆盖其它设置。它还是一个复合规则, 包含多种值, 横跨 存储策略, 过期策略 两种, 同时在请求头和响应头都可设置.
	② Pragma: http1.0字段，指定缓存机制
	③ Expires: http1.0字段，指定缓存的过期时间。即到期时间, 以服务器时间为参考系, 其优先级比 Cache-Control:max-age 低, 两者同时出现在响应头时, Expires将被后者覆盖
	④ Last-Modified: 资源最后一次的修改时间
	⑤ ETag：唯一标识请求资源的字符串。浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高
	
二、缓存协商策略用于重新验证缓存资源是否有效, 有关的key：
	① If-Modified-Since: 缓存校验字段, 值为资源最后一次的修改时间, 即上次收到的Last-Modified值
	② If-Unmodified-Since: 处理方式与上相反
	③ If-Match: 缓存校验字段, 值为唯一标识请求资源的字符串, 即上次收到的ETag值
	④ If-None-Match: 处理方式与上相反


#### 缓存

	1、设置expries 之后 max-age:1000 (from disk cache) 文件过大就会放在磁盘中
	2、文件比较小：200 OK (from memory cache) 是内存中
	3、以上都不会真实的到服务器中
	